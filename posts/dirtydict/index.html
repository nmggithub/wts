<!DOCTYPE html>
<html lang="en" prefix="og: https://ogp.me/ns#">

<head>
  <!-- -- Common -- -->
  <base target="_blank" />
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="referrer" content="no-referrer">
  <meta http-equiv="Content-Security-Policy" content="
      default-src 'none';
      style-src https://fonts.googleapis.com/ 'self';
      font-src https://fonts.gstatic.com/;
      img-src 'self';
      form-action 'none'
      " />
  <link rel="icon" href="/favicon.png" />
  <link rel="stylesheet" href="/style.css" />
  <!-- Site Name -->
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "Watch This Space",
      "url": "https://wts.dev/",
      "description": "A security research blog."
    }
  </script>
  <!-- Mastadon Attribution -->
  <meta name="fediverse:creator" content="@wtsdev@infosec.exchange">
  <!-- Twitter/X use the standard "name" attribute -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@wtsdev" />
  <meta name="twitter:creator" content="@wtsdev" />
  <!-- Facebook/OpenGraph use the non-standard "property" attribute -->
  <meta property="og:site_name" content="Watch This Space" />
  <meta property="og:image" content="https://wts.dev/favicon.png" />
  <meta property="og:image:secure_url" content="https://wts.dev/favicon.png" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:width" content="512" />
  <meta property="og:image:height" content="512" />
  <meta property="og:image:alt" content="A large purple letter W on a light tan background" />
  <!-- -- Page-Specific -- -->
  <!-- Styles -->
  <link rel="stylesheet" href="/post.css" />
  <!-- URL -->
  <link rel="canonical" href="https://wts.dev/posts/dirtydict/" />
  <meta property="og:url" content="https://wts.dev/posts/dirtydict/" />
  <!-- Title -->
  <meta name="og:title" content="DirtyDict: Escaping the macOS Sandbox and wrecking havoc | Watch This Space" />
  <title>DirtyDict: Escaping the macOS Sandbox and wrecking havoc | Watch This Space</title>
  <!-- Description -->
  <meta name="description" content="A security research blog." />
  <meta property="og:description" content="A security research blog." />
  <!-- Additional -->
  <meta property="og:type" content="article" />
  <!-- Author -->
  <meta property="article:author" content="https://github.com/nmggithub" />
  <meta name="author" content="Noah Gregory" />
  <!-- Keywords -->
  <meta name="keywords" content="security,macos,dirtydict,nsspellchecker,nsspellserver,path traversal" />
  <meta property="article:tag" content="security,macos,dirtydict,nsspellchecker,nsspellserver,path traversal" />
</head>

<body>
  <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
    <header>
      <h1 itemprop="headline">DirtyDict: Escaping the macOS Sandbox and wrecking havoc</h1>
      <div id="about">
        <time itemprop="datePublished" datetime="2025-12-18">2025-12-18</time>
        <address itemprop="author" itemscope itemtype="https://schema.org/Person">by <a itemprop="email" title="Send me and email" href="mailto:noah@wts.dev"><span itemprop="name">Noah Gregory</span></a>
        </address>
      </div>
    </header>
    <h2>Introduction</h2>
    <p>Imagine a vulnerability on macOS that would allow a local attacker to read and write to any file on disk, even from within <a href="https://developer.apple.com/documentation/security/app-sandbox">the App Sandbox.</a> That would be quite the very powerful vulnerability. What I found was close to this, although there are a few caveats:</p>
    <ol>
      <li>it only worked on text files,</li>
      <li>its writing ability was limited to appending to the end of the files,</li>
      <li>it could only access files as the logged in user (so no <code>root</code>-owned files), and</li>
      <li>(most unfortunately for any attacker) read files would be returned with their line order scrambled, and append-to files would have their line order scrambled after the appending.</li>
    </ol>
    <p>There was also some caching involved wherein the returned lines may not have matched what was in the target file at that exact time. All of this might seem to severely limit what can be dome with this, but it turns out there are some caveats to the above caveats. But first, I need to explain some things.</p>
    <h2><code>NSSpellServer</code></h2>
    <p>This vulnerability (really a series of vulnerabilities) that I'm calling <b>DirtyDict</b> really starts with <a href="https://developer.apple.com/documentation/foundation/nsspellserver">the <code>NSSpellServer</code> API.</a> This API allows developers to implement their own spell-checkers that can be used via <a href="https://developer.apple.com/documentation/appkit/nsspellchecker">the corollary <code>NSSpellChecker</code> API.</a> I doubt these API's are used all that much in the modern day. They have their origins in NeXTSTEP, likely having existed since the beginning of Mac OS X. The <code>NSSpellServer</code> API itself also had a path traversal vulnerability that was the culprit behind several <abbr title="Common Vulnerabilities and Exposures">CVE</abbr>'s. But before I talk about those, what does any of this have to do with the App Sandbox?</p>
    <h2>The (App) Sandbox</h2>
    <h3>What is the (App) Sandbox?</h3>
    <p>The App Sandbox is actually a subset descriptor of the general concept of sandboxing on macOS. macOS (as well as other Apple OS's) contains a Sandbox kernel module. It uses the <b><a href="http://www.trustedbsd.org/mac.html">TrustedBSD MAC Framework</a></b> I wrote about in <a href="/posts/bypassing-launch-constraints/">one of my previous articles</a> to restrict specific operations. It allows for the creation of profiles that are attached to processes. These profiles are actually highly configurable… just not by you. Many of Apple's own binaries have their own custom sandbox profiles, suited to their needs. But really, the only one third-party developers can use is the App Sandbox.</p>
    <h3>SBPL</h3>
    <p>One undocumented representation of sandbox profiles is a <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>-like language many researchers have taken to calling SBPL (although there doesn't seem to be agreement on if this stands for <q>Sandbox Policy Language</q> or <q>Sandbox Profile language</q>). Regardless, the name is likely taken from the undocumented <code>com.apple.security.temporary-exception.sbpl</code> entitlement, which allows for additional policy rules to be attached to a process. And, despite this entitlement being undocumented, I have seen <a href="https://www.mdsec.co.uk/2018/08/escaping-the-sandbox-microsoft-office-on-macos/">it be used by major third-party applications like Microsoft Office</a> and <a href="https://apps.apple.com/us/app/microsoft-word/id462054704">still be distributed in the Mac App Store.</a> It's unclear to me if Microsoft's size as a company is what has given them enough leverage to do this.</p>
    <h2>How was this a sandbox escape?</h2>
    <p>The SBPL code defining many sandbox profiles can be found in <code>/System/Library/Sandbox/Profiles</code>. The files within are simple text files with the <code>.sb</code> extension, and the <code>application.sb</code> file contains the definition of the profile used by all apps that use the App Sandbox. The <code>NSSpellServer</code> API includes <a href="https://developer.apple.com/documentation/foundation/nsspellserver/registerlanguage(_:byvendor:)">a method to register a spell checker with a language string and a vendor string.</a> While the documentation doesn't explain this, using this method ultimately results in the registration of a Mach service with a name in the format of <code>{language} ({vendor})_OpenStep</code>. Finally, the code inside <code>application.sb</code> ultimately results in the below rule that allows for a sandboxed app to look up any spell server with this name format:</p>
    <pre><code>(allow mach-lookup (global-name-regex "_OpenStep$"))</code></pre>
    <h2>How did DirtyDict work?</h2>
    <p>Spell servers registered with the <code>NSSpellServer</code> API are, behind the scenes, implemented using <b><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/DistrObjects/DistrObjects.html">Distributed Objects,</a></b> a long-since-deprecated set of API's that allowed for Objective-C objects to be used across processes without changing syntax. This API, based around <a href="https://developer.apple.com/documentation/foundation/nsconnection"><code>NSConnection</code></a>) was purposely replaced with XPC (more specifically, <a href="https://developer.apple.com/documentation/foundation/nsxpcconnection"><code>NSXPCConnection</code></a>). As <a href="https://developer.apple.com/forums/thread/772895?answerId=821961022#821961022">Quinn from Apple Developer Technical Support one put it in a support thread:</a> <q>The goal of DO was to hide the IPC as much as possible. That’s not a goal of XPC</q>.</p>
    <p>As spell servers are just distributed objects, that makes it possible to use the <code>NSConnection</code> API's to call methods on the remote servers, even undocumented ones. The path traversal vulnerability existed in two undocumented methods (or rather, both their code paths ultimately led to the same place):</p>
    <ol>
      <li><code>_appendWord:toDictionary:</code></li>
      <li><code>_wordsInDictionary:</code></li>
    </ol>
    <p>The <q>dictionary</q> parameters in both methods are ultimately used to form a path to a what is meant to be a dictionary of words, one per line. As for the line <q>scrambling</q> I mentioned earlier, this is because spell servers return the words/lines in a specifically-sorted order. Spell servers also re-sort the text files after appending a new word/line (although, in some cases, this could be avoided). The root vulnerability was that nowhere in these code paths did the code check the dictionary name for character sequences like <code>..</code>, allowing for path traversal and the reading of / appending to of arbitrary text files.</p>
    <h2>Exploiting DirtyDict</h2>
    <h3>Reading from files</h3>
    <p>The ability to read from files is arguably the more useful primitive of DirtyDict (compared to the ability to write to files). There are many configuration files, often in known locations, where line order doesn't matter that much. For example Chromium-based browsers store many of their config files (including user profiles) in minified JSON files that are just one line. Even un-minified JSON files with known schemas can often be more-or-less deciphered even with their lines scrambled.</p>
    <p>More worrying for developers, <code>.env</code> files containing critical secrets could be compromised through this (as they often include one value per line). While an attacker would have to know the direct path to those files, they could read their editor's config files or even the command line history (<code>~/.zsh_history</code>) to find where project directories live and go from there. They could even potentially utilize local AI to determine directories of interest from the command line history.</p>
    <p>All of this would likely fly under the radar of most <abbr title="Endpoint Detection and Response">EDR</abbr> tools. It's abusing a lower-level (and technically deprecated) IPC interface to proxy file access through what are likely system processes (spell servers built into macOS itself). Conversely, if a piece of malware were to directly reach out to read from files, that would likely be easily caught by any competent security product. I'm unaware of how closely EDR tools monitor the file accesses of system processes, but I wouldn't be surprised if they were given more leeway.</p>
    <h3>Writing to files</h3>
    <h4>Initial Possibilities</h4>
    <p>While writing to files might seem like the less useful primitive due to it being append-only and because of the line scrambling, the latter can be avoided in some cases and even potentially used to an advantage. For the former case, <b>AppleSpell</b> (the main spell server on macOS) actually uses a separate process to perform the post-append sorting. An unsandboxed app could simply wait for such a process to appear and immediately send it a <code>SIGKILL</code> signal. And while an unsandboxed app could likely also reach out to files directly anyway, the benefit of proxying these file writes through spell servers is clear (as discussed above).</p>
    <p>For the latter case (using the sorting to an advantage), its theoretically possible an attacker, if they knew the contents of a target file, could use DirtyDict to append several carefully-crafted lines to a file so that the sorted result is advantageous. For example, if it is a code file that an end user would never look at directly, they could simply append new code lines (prefixed with comments using specific characters to ensure the lines are sorted in the right order) as well as lines that open and close a multi-line comment in such a way that they wrap the original code. For context, I didn't try this myself, but I still do see the possibility.</p>
    <h4>Electron, the App Sandbox, and You</h4>
    <p><b><a href="https://electronjs.org/">Electron</a></b> is an app development framework built on top of Chromium. <a href="/posts/nobjc/">I previously wrote about Electron and how apps written with it are often vulnerable to code-injection unless specific security features are used.</a> The unfortunate thing, as I mentioned in that article, is that it's a widely-held ecosystem policy to ignore local attacks (going all the way up to Chromium). I explain in that article how, while that might make sense on other platforms, it makes less sense on macOS due to its additional security features.</p>
    <p>Some of you may have seen <a href="https://x.com/wtsdev/status/2000610949015736651">my social media post about how Discord (an Electron app) is vulnerable to having a keylogger injected into it.</a> This is actually what I had reported to Discord and received the reply I quote in my previous article. My discovery of this was prompted by <a href="https://wojciechregula.blog/post/electroniz3r/">previous research by Wojciech Reguła</a> as well as <a href="https://x.com/theo/status/1926492374072434895">this tweet by Theo.</a> When I found DirtyDict, I realized its potential for Electron code-injection attacks like this one. While I didn't take the time to create a fully-sandbox-capable version, I was able to inject a keylogger into Discord from an unsandboxed app using DirtyDict. And while DirtyDict has been patched on macOS, likely many Electron apps (like Discord) still remain vulnerable to code injection.</p>
    <h2>A Complete Sandbox Escape</h2>
    <p>While reading from and writing to files are good primitives, we can actually do more with DirtyDict. Using a tactic I learned from <a href="https://www.microsoft.com/en-us/security/blog/2022/07/13/uncovering-a-macos-app-sandbox-escape-vulnerability-a-deep-dive-into-cve-2022-26706/"> this post from Microsoft Threat Intelligence,</a> I figured out I could write commands to a <b><a href="https://effective-shell.com/part-5-building-your-toolkit/configuring-the-shell/">shell config file,</a></b> then open Terminal, and those commands would be executed. As explained in the previous link, shell config files contain what are essentially commands to run before a shell session (which Terminal uses). Some of you may recognize this as <a href="https://attack.mitre.org/techniques/T1546/004/">T1546.004 from the MITRE <abbr title="Adversarial Tactics, Techniques, and Common Knowledge">ATT&CK</abbr>® framework.</a></p>
    <p>Another tatic I used was <a href="https://attack.mitre.org/techniques/T1564/003/">T1564.003 (Hidden Window).</a> Inside their <code>Info.plist</code>'s, <a href="https://developer.apple.com/documentation/bundleresources/information-property-list/lsuielement">apps can define themselves as <q>UI elements,</q></a> in which case they will not have Dock icons. This behavior can actually be given to any app at launch using undocumented options and, in conjunction with other options, <a href="https://gist.github.com/nmggithub/770838bf196265cf23ae01d5ff92e436">can allow for completely silent launching of apps.</a> I figured out this could be used to launch Terminal silently, allowing for a completely invisible (to the end user) sandbox escape.</p>
    <h2>History of DirtyDict</h2>
    <h3>Mickey Jin</h3>
    <p>While I am the first to publicly disclose DirtyDict, I was not the first to find it. That honor goes to <a href="https://x.com/patch1t">Mickey Jin.</a> Mickey is an independent security researcher who is a bit of a legend in the Apple security space. <a href="https://jhftss.github.io/cvelist/">He has over 300 CVE's from Apple from a little over five years of research (as of writing).</a> It was a bug he found in 2023 that, to my knowlege, was the first CVE that can be attributed to DirtyDict.</p>
    <h3>CVE-2023-32444 - Mickey Jin</h3>
    <p><b><a href="https://www.cve.org/CVERecord?id=CVE-2023-32444">CVE-2023-32444</a></b> was a bug in AppleSpell found by Mickey Jin. Mickey privately shared me his notes and gave me permission to speak on this publicly. He found an XPC service (one that used the <a href="https://developer.apple.com/documentation/xpc/xpc-connections">dictionary-based API</a>) that ultimately ended up at the same vulnerable code path in the <code>NSSpellServer</code> API I mentioned earlier. This API was likely written to be a modern replacement to the older <code>NSConnection</code> interface (although it appears all it ultimately does is wrap that older interface). Apple added anti-path-traversal logic to the XPC interface in AppleSpell, but the <code>NSConnection</code> interface was left unpatched.</p>
    <h3>CVE-2024-27887 - Mickey Jin</h3>
    <p><b><a href="https://www.cve.org/CVERecord?id=CVE-2024-27887">CVE-2024-27887</a></b> was a later bug that Mickey found which he described to me as a bypass to the patches for CVE-2023-32444. While he declined to shared further details with me, I did notice (through historical forum posts) that, around the time of the patch, AppleSpell started to use a <a href="https://developer.apple.com/documentation/xcode/accessing-app-group-containers">Group Container.</a> I have my theories on how this might be related to the CVE, but I'll leave disclosure of this bug up to Mickey.</p>
    <h3>CVE-2025-43266 - Noah Gregory</h3>
    <p><b><a href="https://www.cve.org/CVERecord?id=CVE-2025-43266">CVE-2025-43266</a></b> was the first DirtyDict bug I found. I was searching through Mach services and came across the <code>NSConnection</code> ones (there are multiple) from AppleSpell. I traced them back to the <code>NSSpellServer</code> API and found the path traversal vulnerability. I also discovered the aforementioned fact that AppleSpell uses a separate binary for post-append file line sorting. To patch this vulnerability, Apple added anti-path-traversal logic to the <code>NSConnection</code> interface in AppleSpell.</p>
    <h3>CVE-2025-43190 - Noah Gregory</h3>
    <p><b><a href="https://www.cve.org/CVERecord?id=CVE-2025-43190">CVE-2025-43190</a></b> was the second DirtyDict bug I found. It turns out there's a second spell server binary on macOS called <b>OpenSpell.</b> It's normally not active, but it can easily be opened with the following command:</p>
    <pre><code>open /System/Library/Services/OpenSpell.service</code></pre>
    <p>OpenSpell behaved a bit differently than AppleSpell. It did not use a Group Container, and it didn't use a secondary binary for post-append file line sorting (instead opting to do so in-process). Because it is its own binary, separate from AppleSpell, it too needed to be patched with anti-path-traversal logic.</p>
    <h3>CVE-2025-43469 - Mickey Jin</h3>
    <p><b><a href="https://www.cve.org/CVERecord?id=CVE-2025-43469">CVE-2025-43469</a></b> is a mystery to me. Apple listed it under the <code>NSSpellChecker</code> component (and also, as I'm finding out while writing this, under the AppleMobileFileIntegrity component for some reason), so I'm including it here for completeness. However, I have no further information than that. It might not even be related to DirtyDict. I'll let Mickey decide if he ever wants to disclose the details of this bug.</p>
    <h3>CVE-2025-43518 - Noah Gregory</h3>
    <p><b><a href="https://www.cve.org/CVERecord?id=CVE-2025-43518">CVE-2025-43518</a></b> was the third DirtyDict bug I found, and hopefully the last one ever. I told Apple they should probably patch the underlying <code>NSSpellServer</code> API instead of just patching their first-party spell servers, as third-party spell servers remained vulnerable as they (likely) wouldn't have the anti-path-traversal logic Apple added to their own servers. Apple thankfully agreed with me and added anti-path-traversal logic directly into the underlying API. This should hopefully be the end of the DirtyDict saga.</p>
    <h2>Conclusions</h2>
    <p>This article has been a long time coming. I was waiting for at least the underlying <code>NSSpellServer</code> API to be patched before writing about this, as I didn't want to expose end users to unneeded risk. Really, my experience researching DirtyDict (and all the tangential topics I found myself looking into) has taught me how macOS sits high above other platforms when it comes to protections against local attacks. And while <a href="https://x.com/theevilbit/status/1995752897116508668">Apple has frustratingly slashed bounty rewards for reporting such attacks,</a> the security features they have in macOS are almost unparalleled compared to other desktop platforms.</p>
    <p><a href="/posts/nobjc/">The intentional dismissal of local attacks that I pushed back against in my previous article</a> likely stems from the situation on other platforms like Windows and Linux, where <q>local access = game over</q> is still often an unfortunate reality. And while proxying file access through a system process <em>can</em> be beneficial in evading EDR tools, breaking the sandbox barrier is another capability that doesn't have much of a common parallel that I'm aware of on other platforms.</p>
    <p>It's frustrating to me, because I believe filesystem security can be made fundamentally better than it is today, but most of the parties involved don't care enough or refuse to put work into it. Apple could allow end developers to use SBPL to describe more complex sandbox profiles for their apps. Even without that, developers could do more to protect their sensitive files. Beyond this, I believe users can and should be more educated about filesystem security. I hope for a day where <q>local access = game over</q> is no longer something we shrug our shoulders at, but something we actively work towards making more and more untrue.</p>
    <p>To keep up to date with what I post here, remember to <a target="_self" href="/feed.xml">watch this space.</a></p>
  </article>
</body>

</html>